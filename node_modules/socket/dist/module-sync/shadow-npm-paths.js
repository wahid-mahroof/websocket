'use strict';

function _socketInterop(e) {
  let c = 0
  for (const k in e ?? {}) {
    c = c === 0 && k === 'default' ? 1 : 0
    if (!c && k !== '__esModule') break
  }
  return c ? e.default : e
}

var fs = require('node:fs');
var Module = require('node:module');
var path = require('node:path');
var process = require('node:process');
var logger = require('@socketsecurity/registry/lib/logger');
var path$1 = require('@socketsecurity/registry/lib/path');
var constants = require('./constants.js');
var ignore = _socketInterop(require('ignore'));
var micromatch = _socketInterop(require('micromatch'));
var tinyglobby = _socketInterop(require('tinyglobby'));
var which = _socketInterop(require('which'));
var debug = require('@socketsecurity/registry/lib/debug');

const ignoredDirs = [
// Taken from ignore-by-default:
// https://github.com/novemberborn/ignore-by-default/blob/v2.1.0/index.js
'.git',
// Git repository files, see <https://git-scm.com/>
'.log',
// Log files emitted by tools such as `tsserver`, see <https://github.com/Microsoft/TypeScript/wiki/Standalone-Server-%28tsserver%29>
'.nyc_output',
// Temporary directory where nyc stores coverage data, see <https://github.com/bcoe/nyc>
'.sass-cache',
// Cache folder for node-sass, see <https://github.com/sass/node-sass>
'.yarn',
// Where node modules are installed when using Yarn, see <https://yarnpkg.com/>
'bower_components',
// Where Bower packages are installed, see <http://bower.io/>
'coverage',
// Standard output directory for code coverage reports, see <https://github.com/gotwarlost/istanbul>
'node_modules',
// Where Node modules are installed, see <https://nodejs.org/>
// Taken from globby:
// https://github.com/sindresorhus/globby/blob/v14.0.2/ignore.js#L11-L16
'flow-typed'];
const ignoredDirPatterns = ignoredDirs.map(i => `**/${i}`);
function directoryPatterns() {
  return [...ignoredDirPatterns];
}

const {
  NODE_MODULES: NODE_MODULES$1,
  NPM: NPM$1,
  shadowBinPath
} = constants;
async function filterGlobResultToSupportedFiles(entries, supportedFiles) {
  const patterns = ['golang', NPM$1, 'maven', 'pypi'].reduce((r, n) => {
    const supported = supportedFiles[n];
    r.push(...(supported ? Object.values(supported).map(p => `**/${p.pattern}`) : []));
    return r;
  }, []);
  return entries.filter(p => micromatch.some(p, patterns));
}
async function globWithGitIgnore(patterns, options) {
  const {
    cwd = process.cwd(),
    socketConfig,
    ...additionalOptions
  } = {
    __proto__: null,
    ...options
  };
  const projectIgnorePaths = socketConfig?.projectIgnorePaths;
  const ignoreFiles = await tinyglobby.glob(['**/.gitignore'], {
    absolute: true,
    cwd,
    expandDirectories: true
  });
  const ignores = [...directoryPatterns(), ...(Array.isArray(projectIgnorePaths) ? ignoreFileLinesToGlobPatterns(projectIgnorePaths, path.join(cwd, '.gitignore'), cwd) : []), ...(await Promise.all(ignoreFiles.map(async filepath => ignoreFileToGlobPatterns(await fs.promises.readFile(filepath, 'utf8'), filepath, cwd)))).flat()];
  const hasNegatedPattern = ignores.some(p => p.charCodeAt(0) === 33 /*'!'*/);
  const globOptions = {
    absolute: true,
    cwd,
    expandDirectories: false,
    ignore: hasNegatedPattern ? [] : ignores,
    ...additionalOptions
  };
  const result = await tinyglobby.glob(patterns, globOptions);
  if (!hasNegatedPattern) {
    return result;
  }
  const {
    absolute
  } = globOptions;

  // Note: the input files must be INSIDE the cwd. If you get strange looking
  // relative path errors here, most likely your path is outside the given cwd.
  const filtered = ignore().add(ignores).filter(absolute ? result.map(p => path.relative(cwd, p)) : result);
  return absolute ? filtered.map(p => path.resolve(cwd, p)) : filtered;
}
function ignoreFileLinesToGlobPatterns(lines, filepath, cwd) {
  const base = path.relative(cwd, path.dirname(filepath)).replace(/\\/g, '/');
  const patterns = [];
  for (let i = 0, {
      length
    } = lines; i < length; i += 1) {
    const pattern = lines[i].trim();
    if (pattern.length > 0 && pattern.charCodeAt(0) !== 35 /*'#'*/) {
      patterns.push(ignorePatternToMinimatch(pattern.length && pattern.charCodeAt(0) === 33 /*'!'*/ ? `!${path.posix.join(base, pattern.slice(1))}` : path.posix.join(base, pattern)));
    }
  }
  return patterns;
}
function ignoreFileToGlobPatterns(content, filepath, cwd) {
  return ignoreFileLinesToGlobPatterns(content.split(/\r?\n/), filepath, cwd);
}

// Based on `@eslint/compat` convertIgnorePatternToMinimatch.
// Apache v2.0 licensed
// Copyright Nicholas C. Zakas
// https://github.com/eslint/rewrite/blob/compat-v1.2.1/packages/compat/src/ignore-file.js#L28
function ignorePatternToMinimatch(pattern) {
  const isNegated = pattern.startsWith('!');
  const negatedPrefix = isNegated ? '!' : '';
  const patternToTest = (isNegated ? pattern.slice(1) : pattern).trimEnd();
  // Special cases.
  if (patternToTest === '' || patternToTest === '**' || patternToTest === '/**' || patternToTest === '**') {
    return `${negatedPrefix}${patternToTest}`;
  }
  const firstIndexOfSlash = patternToTest.indexOf('/');
  const matchEverywherePrefix = firstIndexOfSlash === -1 || firstIndexOfSlash === patternToTest.length - 1 ? '**/' : '';
  const patternWithoutLeadingSlash = firstIndexOfSlash === 0 ? patternToTest.slice(1) : patternToTest;
  // Escape `{` and `(` because in gitignore patterns they are just
  // literal characters without any specific syntactic meaning,
  // while in minimatch patterns they can form brace expansion or extglob syntax.
  //
  // For example, gitignore pattern `src/{a,b}.js` ignores file `src/{a,b}.js`.
  // But, the same minimatch pattern `src/{a,b}.js` ignores files `src/a.js` and `src/b.js`.
  // Minimatch pattern `src/\{a,b}.js` is equivalent to gitignore pattern `src/{a,b}.js`.
  const escapedPatternWithoutLeadingSlash = patternWithoutLeadingSlash.replaceAll(/(?=((?:\\.|[^{(])*))\1([{(])/guy, '$1\\$2');
  const matchInsideSuffix = patternToTest.endsWith('/**') ? '/*' : '';
  return `${negatedPrefix}${matchEverywherePrefix}${escapedPatternWithoutLeadingSlash}${matchInsideSuffix}`;
}
function pathsToPatterns(paths) {
  // TODO: Does not support `~/` paths.
  return paths.map(p => p === '.' ? '**/*' : p);
}
function findBinPathDetailsSync(binName) {
  let shadowIndex = -1;
  const bins = which.sync(binName, {
    all: true,
    nothrow: true
  }) ?? [];
  let binPath;
  for (let i = 0, {
      length
    } = bins; i < length; i += 1) {
    const bin = fs.realpathSync.native(bins[i]);
    // Skip our bin directory if it's in the front.
    if (path.dirname(bin) === shadowBinPath) {
      shadowIndex = i;
    } else {
      binPath = bin;
      break;
    }
  }
  return {
    name: binName,
    path: binPath,
    shadowed: shadowIndex !== -1
  };
}
function findNpmPathSync(npmBinPath) {
  let thePath = npmBinPath;
  while (true) {
    const nmPath = path.join(thePath, NODE_MODULES$1);
    if (
    // npm bin paths may look like:
    // /usr/local/share/npm/bin/npm
    // /Users/SomeUsername/.nvm/versions/node/vX.X.X/bin/npm
    // C:\Users\SomeUsername\AppData\Roaming\npm\bin\npm.cmd
    // OR
    // C:\Program Files\nodejs\npm.cmd
    //
    // In all cases the npm path contains a node_modules folder:
    // /usr/local/share/npm/bin/npm/node_modules
    // C:\Program Files\nodejs\node_modules
    //
    // Use existsSync here because statsSync, even with { throwIfNoEntry: false },
    // will throw an ENOTDIR error for paths like ./a-file-that-exists/a-directory-that-does-not.
    // See https://github.com/nodejs/node/issues/56993.
    fs.existsSync(nmPath) && fs.statSync(nmPath, {
      throwIfNoEntry: false
    })?.isDirectory() && (
    // Optimistically look for the default location.
    path.basename(thePath) === NPM$1 ||
    // Chocolatey installs npm bins in the same directory as node bins.
    // Lazily access constants.WIN32.
    constants.WIN32 && fs.existsSync(path.join(thePath, `${NPM$1}.cmd`)))) {
      return thePath;
    }
    const parent = path.dirname(thePath);
    if (parent === thePath) {
      return undefined;
    }
    thePath = parent;
  }
}
async function getPackageFilesFullScans(cwd, inputPaths, supportedFiles, config) {
  debug.debugLog(`Globbed resolving ${inputPaths.length} paths:`, inputPaths);
  const entries = await globWithGitIgnore(pathsToPatterns(inputPaths), {
    cwd,
    socketConfig: config
  });
  debug.debugLog(`Globbed resolved ${inputPaths.length} paths to ${entries.length} paths:`, entries);
  const packageFiles = await filterGlobResultToSupportedFiles(entries, supportedFiles);
  debug.debugLog(`Mapped ${entries.length} entries to ${packageFiles.length} files:`, packageFiles);
  return packageFiles;
}

const {
  NODE_MODULES,
  NPM,
  NPX,
  SOCKET_CLI_ISSUES_URL
} = constants;
function exitWithBinPathError(binName) {
  logger.logger.fail(`Socket unable to locate ${binName}; ensure it is available in the PATH environment variable.`);
  // The exit code 127 indicates that the command or binary being executed
  // could not be found.
  process.exit(127);
}
let _npmBinPathDetails;
function getNpmBinPathDetails() {
  if (_npmBinPathDetails === undefined) {
    _npmBinPathDetails = findBinPathDetailsSync(NPM);
  }
  return _npmBinPathDetails;
}
let _npxBinPathDetails;
function getNpxBinPathDetails() {
  if (_npxBinPathDetails === undefined) {
    _npxBinPathDetails = findBinPathDetailsSync(NPX);
  }
  return _npxBinPathDetails;
}
let _npmBinPath;
function getNpmBinPath() {
  if (_npmBinPath === undefined) {
    _npmBinPath = getNpmBinPathDetails().path;
    if (!_npmBinPath) {
      exitWithBinPathError(NPM);
    }
  }
  return _npmBinPath;
}
function isNpmBinPathShadowed() {
  return getNpmBinPathDetails().shadowed;
}
let _npxBinPath;
function getNpxBinPath() {
  if (_npxBinPath === undefined) {
    _npxBinPath = getNpxBinPathDetails().path;
    if (!_npxBinPath) {
      exitWithBinPathError(NPX);
    }
  }
  return _npxBinPath;
}
function isNpxBinPathShadowed() {
  return getNpxBinPathDetails().shadowed;
}
let _npmPath;
function getNpmPath() {
  if (_npmPath === undefined) {
    const npmBinPath = getNpmBinPath();
    _npmPath = npmBinPath ? findNpmPathSync(npmBinPath) : undefined;
    if (!_npmPath) {
      let message = 'Unable to find npm CLI install directory.';
      if (npmBinPath) {
        message += `\nSearched parent directories of ${path.dirname(npmBinPath)}.`;
      }
      message += `\n\nThis is may be a bug with socket-npm related to changes to the npm CLI.\nPlease report to ${SOCKET_CLI_ISSUES_URL}.`;
      logger.logger.fail(message);
      // The exit code 127 indicates that the command or binary being executed
      // could not be found.
      process.exit(127);
    }
  }
  return _npmPath;
}
let _npmRequire;
function getNpmRequire() {
  if (_npmRequire === undefined) {
    const npmPath = getNpmPath();
    const npmNmPath = path.join(npmPath, NODE_MODULES, NPM);
    _npmRequire = Module.createRequire(path.join(fs.existsSync(npmNmPath) ? npmNmPath : npmPath, '<dummy-basename>'));
  }
  return _npmRequire;
}
let _arboristPkgPath;
function getArboristPackagePath() {
  if (_arboristPkgPath === undefined) {
    const pkgName = '@npmcli/arborist';
    const mainPathWithForwardSlashes = path$1.normalizePath(getNpmRequire().resolve(pkgName));
    const arboristPkgPathWithForwardSlashes = mainPathWithForwardSlashes.slice(0, mainPathWithForwardSlashes.lastIndexOf(pkgName) + pkgName.length);
    // Lazily access constants.WIN32.
    _arboristPkgPath = constants.WIN32 ? path.normalize(arboristPkgPathWithForwardSlashes) : arboristPkgPathWithForwardSlashes;
  }
  return _arboristPkgPath;
}
let _arboristClassPath;
function getArboristClassPath() {
  if (_arboristClassPath === undefined) {
    _arboristClassPath = path.join(getArboristPackagePath(), 'lib/arborist/index.js');
  }
  return _arboristClassPath;
}
let _arboristDepValidPath;
function getArboristDepValidPath() {
  if (_arboristDepValidPath === undefined) {
    _arboristDepValidPath = path.join(getArboristPackagePath(), 'lib/dep-valid.js');
  }
  return _arboristDepValidPath;
}
let _arboristEdgeClassPath;
function getArboristEdgeClassPath() {
  if (_arboristEdgeClassPath === undefined) {
    _arboristEdgeClassPath = path.join(getArboristPackagePath(), 'lib/edge.js');
  }
  return _arboristEdgeClassPath;
}
let _arboristNodeClassPath;
function getArboristNodeClassPath() {
  if (_arboristNodeClassPath === undefined) {
    _arboristNodeClassPath = path.join(getArboristPackagePath(), 'lib/node.js');
  }
  return _arboristNodeClassPath;
}
let _arboristOverrideSetClassPath;
function getArboristOverrideSetClassPath() {
  if (_arboristOverrideSetClassPath === undefined) {
    _arboristOverrideSetClassPath = path.join(getArboristPackagePath(), 'lib/override-set.js');
  }
  return _arboristOverrideSetClassPath;
}

exports.getArboristClassPath = getArboristClassPath;
exports.getArboristDepValidPath = getArboristDepValidPath;
exports.getArboristEdgeClassPath = getArboristEdgeClassPath;
exports.getArboristNodeClassPath = getArboristNodeClassPath;
exports.getArboristOverrideSetClassPath = getArboristOverrideSetClassPath;
exports.getNpmBinPath = getNpmBinPath;
exports.getNpmRequire = getNpmRequire;
exports.getNpxBinPath = getNpxBinPath;
exports.getPackageFilesFullScans = getPackageFilesFullScans;
exports.isNpmBinPathShadowed = isNpmBinPathShadowed;
exports.isNpxBinPathShadowed = isNpxBinPathShadowed;
//# debugId=cc70a9f1-74e4-4753-bc40-9d6daed82e9e
//# sourceMappingURL=shadow-npm-paths.js.map
