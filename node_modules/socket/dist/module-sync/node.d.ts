/// <reference types="npmcli__arborist" />
import { SafeOverrideSet } from "./override-set.js";
import { SafeEdge } from "./edge.js";
import { Link } from '@npmcli/arborist';
import { Node as BaseNode } from "@npmcli/arborist";
type NodeClass = Omit<BaseNode, 'addEdgeIn' | 'addEdgeOut' | 'canDedupe' | 'canReplace' | 'canReplaceWith' | 'children' | 'deleteEdgeIn' | 'edgesIn' | 'edgesOut' | 'from' | 'hasShrinkwrap' | 'inDepBundle' | 'inShrinkwrap' | 'integrity' | 'isTop' | 'matches' | 'meta' | 'name' | 'overrides' | 'packageName' | 'parent' | 'recalculateOutEdgesOverrides' | 'resolve' | 'resolveParent' | 'root' | 'updateOverridesEdgeInAdded' | 'updateOverridesEdgeInRemoved' | 'version' | 'versions'> & {
    name: string;
    version: string;
    children: Map<string, SafeNode | Link>;
    edgesIn: Set<SafeEdge>;
    edgesOut: Map<string, SafeEdge>;
    from: SafeNode | null;
    hasShrinkwrap: boolean;
    inShrinkwrap: boolean | undefined;
    integrity?: string | null;
    isTop: boolean | undefined;
    meta: BaseNode['meta'] & {
        addEdge(edge: SafeEdge): void;
    };
    overrides: SafeOverrideSet | undefined;
    versions: string[];
    get inDepBundle(): boolean;
    get packageName(): string | null;
    get parent(): SafeNode | null;
    set parent(value: SafeNode | null);
    get resolveParent(): SafeNode | null;
    get root(): SafeNode | null;
    set root(value: SafeNode | null);
    new (...args: any): NodeClass;
    addEdgeIn(edge: SafeEdge): void;
    addEdgeOut(edge: SafeEdge): void;
    canDedupe(preferDedupe?: boolean): boolean;
    canReplace(node: SafeNode, ignorePeers?: string[]): boolean;
    canReplaceWith(node: SafeNode, ignorePeers?: string[]): boolean;
    deleteEdgeIn(edge: SafeEdge): void;
    matches(node: SafeNode): boolean;
    recalculateOutEdgesOverrides(): void;
    resolve(name: string): SafeNode;
    updateOverridesEdgeInAdded(otherOverrideSet: SafeOverrideSet | undefined): boolean;
    updateOverridesEdgeInRemoved(otherOverrideSet: SafeOverrideSet): boolean;
};
declare const Node: NodeClass;
declare class SafeNode extends Node {
    // Return true if it's safe to remove this node, because anything that is
    // depending on it would be fine with the thing that they would resolve to if
    // it was removed, or nothing is depending on it in the first place.
    canDedupe(preferDedupe?: boolean): boolean;
    // Is it safe to replace one node with another?  check the edges to
    // make sure no one will get upset.  Note that the node might end up
    // having its own unmet dependencies, if the new node has new deps.
    // Note that there are cases where Arborist will opt to insert a node
    // into the tree even though this function returns false!  This is
    // necessary when a root dependency is added or updated, or when a
    // root dependency brings peer deps along with it.  In that case, we
    // will go ahead and create the invalid state, and then try to resolve
    // it with more tree construction, because it's a user request.
    canReplaceWith(node: SafeNode, ignorePeers?: string[]): boolean;
    // Patch adding deleteEdgeIn is based on https://github.com/npm/cli/pull/8089.
    deleteEdgeIn(edge: SafeEdge): void;
    addEdgeIn(edge: SafeEdge): void;
    get overridden(): boolean;
    set parent(newParent: SafeNode);
    // Patch adding recalculateOutEdgesOverrides is based on
    // https://github.com/npm/cli/pull/8089.
    recalculateOutEdgesOverrides(): void;
    set root(newRoot: SafeNode);
    // Patch adding updateOverridesEdgeInAdded is based on
    // https://github.com/npm/cli/pull/7025.
    //
    // This logic isn't perfect either. When we have two edges in that have
    // different override sets, then we have to decide which set is correct. This
    // function assumes the more specific override set is applicable, so if we have
    // dependencies A->B->C and A->C and an override set that specifies what happens
    // for C under A->B, this will work even if the new A->C edge comes along and
    // tries to change the override set. The strictly correct logic is not to allow
    // two edges with different overrides to point to the same node, because even
    // if this node can satisfy both, one of its dependencies might need to be
    // different depending on the edge leading to it. However, this might cause a
    // lot of duplication, because the conflict in the dependencies might never
    // actually happen.
    updateOverridesEdgeInAdded(otherOverrideSet: SafeOverrideSet | undefined): boolean;
    // Patch adding updateOverridesEdgeInRemoved is based on
    // https://github.com/npm/cli/pull/7025.
    updateOverridesEdgeInRemoved(otherOverrideSet: SafeOverrideSet): boolean;
}
export { SafeNode };
